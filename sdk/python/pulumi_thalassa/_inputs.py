# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'KubernetesClusterApiServerAclArgs',
    'KubernetesClusterApiServerAclArgsDict',
    'KubernetesNodePoolNodeTaintArgs',
    'KubernetesNodePoolNodeTaintArgsDict',
    'SecurityGroupEgressRuleArgs',
    'SecurityGroupEgressRuleArgsDict',
    'SecurityGroupIngressRuleArgs',
    'SecurityGroupIngressRuleArgsDict',
    'TargetGroupAttachmentArgs',
    'TargetGroupAttachmentArgsDict',
]

MYPY = False

if not MYPY:
    class KubernetesClusterApiServerAclArgsDict(TypedDict):
        allowed_cidrs: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of allowed CIDRs for API server access
        """
elif False:
    KubernetesClusterApiServerAclArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesClusterApiServerAclArgs:
    def __init__(__self__, *,
                 allowed_cidrs: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_cidrs: List of allowed CIDRs for API server access
        """
        if allowed_cidrs is not None:
            pulumi.set(__self__, "allowed_cidrs", allowed_cidrs)

    @_builtins.property
    @pulumi.getter(name="allowedCidrs")
    def allowed_cidrs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of allowed CIDRs for API server access
        """
        return pulumi.get(self, "allowed_cidrs")

    @allowed_cidrs.setter
    def allowed_cidrs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_cidrs", value)


if not MYPY:
    class KubernetesNodePoolNodeTaintArgsDict(TypedDict):
        effect: NotRequired[pulumi.Input[_builtins.str]]
        """
        Effect of the taint
        """
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Key of the taint
        """
        operator: NotRequired[pulumi.Input[_builtins.str]]
        """
        Operator of the taint
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Value of the taint. Optional.
        """
elif False:
    KubernetesNodePoolNodeTaintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesNodePoolNodeTaintArgs:
    def __init__(__self__, *,
                 effect: Optional[pulumi.Input[_builtins.str]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 operator: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] effect: Effect of the taint
        :param pulumi.Input[_builtins.str] key: Key of the taint
        :param pulumi.Input[_builtins.str] operator: Operator of the taint
        :param pulumi.Input[_builtins.str] value: Value of the taint. Optional.
        """
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Effect of the taint
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "effect", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Key of the taint
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Operator of the taint
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Value of the taint. Optional.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SecurityGroupEgressRuleArgsDict(TypedDict):
        ip_version: pulumi.Input[_builtins.str]
        """
        IP version of the rule (ipv4 or ipv6)
        """
        name: pulumi.Input[_builtins.str]
        """
        Name of the rule
        """
        policy: pulumi.Input[_builtins.str]
        """
        Policy of the rule (allow or drop)
        """
        priority: pulumi.Input[_builtins.int]
        """
        Priority of the rule. Must be greater than 0 and less than 200.
        """
        protocol: pulumi.Input[_builtins.str]
        """
        Protocol of the rule (all, tcp, udp, icmp)
        """
        remote_type: pulumi.Input[_builtins.str]
        """
        Type of the remote address (address or securityGroup)
        """
        port_range_max: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum port of the rule. Must be greater than 0 and less than 65535.
        """
        port_range_min: NotRequired[pulumi.Input[_builtins.int]]
        """
        Minimum port of the rule. Must be greater than 0 and less than 65535.
        """
        remote_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        IP address or CIDR block that the rule applies to
        """
        remote_security_group_identity: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identity of the security group that the rule applies to
        """
elif False:
    SecurityGroupEgressRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityGroupEgressRuleArgs:
    def __init__(__self__, *,
                 ip_version: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 policy: pulumi.Input[_builtins.str],
                 priority: pulumi.Input[_builtins.int],
                 protocol: pulumi.Input[_builtins.str],
                 remote_type: pulumi.Input[_builtins.str],
                 port_range_max: Optional[pulumi.Input[_builtins.int]] = None,
                 port_range_min: Optional[pulumi.Input[_builtins.int]] = None,
                 remote_address: Optional[pulumi.Input[_builtins.str]] = None,
                 remote_security_group_identity: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ip_version: IP version of the rule (ipv4 or ipv6)
        :param pulumi.Input[_builtins.str] name: Name of the rule
        :param pulumi.Input[_builtins.str] policy: Policy of the rule (allow or drop)
        :param pulumi.Input[_builtins.int] priority: Priority of the rule. Must be greater than 0 and less than 200.
        :param pulumi.Input[_builtins.str] protocol: Protocol of the rule (all, tcp, udp, icmp)
        :param pulumi.Input[_builtins.str] remote_type: Type of the remote address (address or securityGroup)
        :param pulumi.Input[_builtins.int] port_range_max: Maximum port of the rule. Must be greater than 0 and less than 65535.
        :param pulumi.Input[_builtins.int] port_range_min: Minimum port of the rule. Must be greater than 0 and less than 65535.
        :param pulumi.Input[_builtins.str] remote_address: IP address or CIDR block that the rule applies to
        :param pulumi.Input[_builtins.str] remote_security_group_identity: Identity of the security group that the rule applies to
        """
        pulumi.set(__self__, "ip_version", ip_version)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "policy", policy)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "remote_type", remote_type)
        if port_range_max is not None:
            pulumi.set(__self__, "port_range_max", port_range_max)
        if port_range_min is not None:
            pulumi.set(__self__, "port_range_min", port_range_min)
        if remote_address is not None:
            pulumi.set(__self__, "remote_address", remote_address)
        if remote_security_group_identity is not None:
            pulumi.set(__self__, "remote_security_group_identity", remote_security_group_identity)

    @_builtins.property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> pulumi.Input[_builtins.str]:
        """
        IP version of the rule (ipv4 or ipv6)
        """
        return pulumi.get(self, "ip_version")

    @ip_version.setter
    def ip_version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip_version", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> pulumi.Input[_builtins.str]:
        """
        Policy of the rule (allow or drop)
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "policy", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        """
        Priority of the rule. Must be greater than 0 and less than 200.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[_builtins.str]:
        """
        Protocol of the rule (all, tcp, udp, icmp)
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="remoteType")
    def remote_type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of the remote address (address or securityGroup)
        """
        return pulumi.get(self, "remote_type")

    @remote_type.setter
    def remote_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "remote_type", value)

    @_builtins.property
    @pulumi.getter(name="portRangeMax")
    def port_range_max(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum port of the rule. Must be greater than 0 and less than 65535.
        """
        return pulumi.get(self, "port_range_max")

    @port_range_max.setter
    def port_range_max(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_range_max", value)

    @_builtins.property
    @pulumi.getter(name="portRangeMin")
    def port_range_min(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Minimum port of the rule. Must be greater than 0 and less than 65535.
        """
        return pulumi.get(self, "port_range_min")

    @port_range_min.setter
    def port_range_min(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_range_min", value)

    @_builtins.property
    @pulumi.getter(name="remoteAddress")
    def remote_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IP address or CIDR block that the rule applies to
        """
        return pulumi.get(self, "remote_address")

    @remote_address.setter
    def remote_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "remote_address", value)

    @_builtins.property
    @pulumi.getter(name="remoteSecurityGroupIdentity")
    def remote_security_group_identity(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identity of the security group that the rule applies to
        """
        return pulumi.get(self, "remote_security_group_identity")

    @remote_security_group_identity.setter
    def remote_security_group_identity(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "remote_security_group_identity", value)


if not MYPY:
    class SecurityGroupIngressRuleArgsDict(TypedDict):
        ip_version: pulumi.Input[_builtins.str]
        """
        IP version of the rule (ipv4 or ipv6)
        """
        name: pulumi.Input[_builtins.str]
        """
        Name of the rule
        """
        policy: pulumi.Input[_builtins.str]
        """
        Policy of the rule (allow or drop)
        """
        priority: pulumi.Input[_builtins.int]
        """
        Priority of the rule. Must be greater than 0 and less than 200.
        """
        protocol: pulumi.Input[_builtins.str]
        """
        Protocol of the rule (all, tcp, udp, icmp)
        """
        remote_type: pulumi.Input[_builtins.str]
        """
        Type of the remote address (address or securityGroup)
        """
        port_range_max: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum port of the rule. Must be greater than 0 and less than 65535.
        """
        port_range_min: NotRequired[pulumi.Input[_builtins.int]]
        """
        Minimum port of the rule. Must be greater than 0 and less than 65535.
        """
        remote_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        IP address or CIDR block that the rule applies to
        """
        remote_security_group_identity: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identity of the security group that the rule applies to
        """
elif False:
    SecurityGroupIngressRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityGroupIngressRuleArgs:
    def __init__(__self__, *,
                 ip_version: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 policy: pulumi.Input[_builtins.str],
                 priority: pulumi.Input[_builtins.int],
                 protocol: pulumi.Input[_builtins.str],
                 remote_type: pulumi.Input[_builtins.str],
                 port_range_max: Optional[pulumi.Input[_builtins.int]] = None,
                 port_range_min: Optional[pulumi.Input[_builtins.int]] = None,
                 remote_address: Optional[pulumi.Input[_builtins.str]] = None,
                 remote_security_group_identity: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ip_version: IP version of the rule (ipv4 or ipv6)
        :param pulumi.Input[_builtins.str] name: Name of the rule
        :param pulumi.Input[_builtins.str] policy: Policy of the rule (allow or drop)
        :param pulumi.Input[_builtins.int] priority: Priority of the rule. Must be greater than 0 and less than 200.
        :param pulumi.Input[_builtins.str] protocol: Protocol of the rule (all, tcp, udp, icmp)
        :param pulumi.Input[_builtins.str] remote_type: Type of the remote address (address or securityGroup)
        :param pulumi.Input[_builtins.int] port_range_max: Maximum port of the rule. Must be greater than 0 and less than 65535.
        :param pulumi.Input[_builtins.int] port_range_min: Minimum port of the rule. Must be greater than 0 and less than 65535.
        :param pulumi.Input[_builtins.str] remote_address: IP address or CIDR block that the rule applies to
        :param pulumi.Input[_builtins.str] remote_security_group_identity: Identity of the security group that the rule applies to
        """
        pulumi.set(__self__, "ip_version", ip_version)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "policy", policy)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "remote_type", remote_type)
        if port_range_max is not None:
            pulumi.set(__self__, "port_range_max", port_range_max)
        if port_range_min is not None:
            pulumi.set(__self__, "port_range_min", port_range_min)
        if remote_address is not None:
            pulumi.set(__self__, "remote_address", remote_address)
        if remote_security_group_identity is not None:
            pulumi.set(__self__, "remote_security_group_identity", remote_security_group_identity)

    @_builtins.property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> pulumi.Input[_builtins.str]:
        """
        IP version of the rule (ipv4 or ipv6)
        """
        return pulumi.get(self, "ip_version")

    @ip_version.setter
    def ip_version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip_version", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> pulumi.Input[_builtins.str]:
        """
        Policy of the rule (allow or drop)
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "policy", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        """
        Priority of the rule. Must be greater than 0 and less than 200.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[_builtins.str]:
        """
        Protocol of the rule (all, tcp, udp, icmp)
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="remoteType")
    def remote_type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of the remote address (address or securityGroup)
        """
        return pulumi.get(self, "remote_type")

    @remote_type.setter
    def remote_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "remote_type", value)

    @_builtins.property
    @pulumi.getter(name="portRangeMax")
    def port_range_max(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum port of the rule. Must be greater than 0 and less than 65535.
        """
        return pulumi.get(self, "port_range_max")

    @port_range_max.setter
    def port_range_max(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_range_max", value)

    @_builtins.property
    @pulumi.getter(name="portRangeMin")
    def port_range_min(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Minimum port of the rule. Must be greater than 0 and less than 65535.
        """
        return pulumi.get(self, "port_range_min")

    @port_range_min.setter
    def port_range_min(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_range_min", value)

    @_builtins.property
    @pulumi.getter(name="remoteAddress")
    def remote_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IP address or CIDR block that the rule applies to
        """
        return pulumi.get(self, "remote_address")

    @remote_address.setter
    def remote_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "remote_address", value)

    @_builtins.property
    @pulumi.getter(name="remoteSecurityGroupIdentity")
    def remote_security_group_identity(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identity of the security group that the rule applies to
        """
        return pulumi.get(self, "remote_security_group_identity")

    @remote_security_group_identity.setter
    def remote_security_group_identity(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "remote_security_group_identity", value)


if not MYPY:
    class TargetGroupAttachmentArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of the target (e.g. instance ID)
        """
elif False:
    TargetGroupAttachmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetGroupAttachmentArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the target (e.g. instance ID)
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the target (e.g. instance ID)
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


