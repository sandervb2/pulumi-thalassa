// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package thalassa

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/sandervb2/pulumi-thalassa/sdk/go/thalassa/internal"
)

// Create a target group for a load balancer
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/sandervb2/pulumi-thalassa/sdk/go/thalassa"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			// Create a VPC for the target group
//			example, err := thalassa.NewVpc(ctx, "example", &thalassa.VpcArgs{
//				Name:        pulumi.String("example-vpc"),
//				Description: pulumi.String("Example VPC for target group"),
//				Region:      pulumi.String("nl-01"),
//				Cidrs: pulumi.StringArray{
//					pulumi.String("10.0.0.0/16"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			// Create a target group with all optional attributes
//			exampleTargetGroup, err := thalassa.NewTargetGroup(ctx, "example", &thalassa.TargetGroupArgs{
//				Name:        pulumi.String("example-target-group"),
//				VpcId:       example.ID(),
//				Protocol:    pulumi.String("tcp"),
//				Port:        pulumi.Int(80),
//				Description: pulumi.String("Example target group for documentation with all optional attributes"),
//				Labels: pulumi.StringMap{
//					"environment": pulumi.String("production"),
//					"service":     pulumi.String("web"),
//					"tier":        pulumi.String("backend"),
//				},
//				HealthCheckProtocol: pulumi.String("http"),
//				HealthCheckPort:     pulumi.Int(80),
//				HealthCheckPath:     pulumi.String("/health"),
//				HealthCheckInterval: pulumi.Int(30),
//				HealthCheckTimeout:  pulumi.Int(5),
//				HealthyThreshold:    pulumi.Int(3),
//				UnhealthyThreshold:  pulumi.Int(3),
//			})
//			if err != nil {
//				return err
//			}
//			ctx.Export("targetGroupId", exampleTargetGroup.ID())
//			return nil
//		})
//	}
//
// ```
type TargetGroup struct {
	pulumi.CustomResourceState

	// Annotations for the Target Group
	Annotations pulumi.StringMapOutput `pulumi:"annotations"`
	// The targets to attach to the target group. If provided, the targets will be attached to the target group when the resource is created. Overwrites the target group attachment resource.
	Attachments TargetGroupAttachmentTypeArrayOutput `pulumi:"attachments"`
	// A human readable description about the target group
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// The approximate amount of time, in seconds, between health checks of an individual target
	HealthCheckInterval pulumi.IntPtrOutput `pulumi:"healthCheckInterval"`
	// The path to use for health checks (only for HTTP/HTTPS)
	HealthCheckPath pulumi.StringPtrOutput `pulumi:"healthCheckPath"`
	// The port to use for health checks
	HealthCheckPort pulumi.IntPtrOutput `pulumi:"healthCheckPort"`
	// The protocol to use for health checks. Must be one of: tcp, http.
	HealthCheckProtocol pulumi.StringPtrOutput `pulumi:"healthCheckProtocol"`
	// The amount of time, in seconds, during which no response means a failed health check
	HealthCheckTimeout pulumi.IntPtrOutput `pulumi:"healthCheckTimeout"`
	// The number of consecutive health checks successes required before considering an unhealthy target healthy
	HealthyThreshold pulumi.IntPtrOutput `pulumi:"healthyThreshold"`
	// Labels for the Target Group
	Labels pulumi.StringMapOutput `pulumi:"labels"`
	// Name of the Target Group
	Name           pulumi.StringOutput    `pulumi:"name"`
	OrganisationId pulumi.StringPtrOutput `pulumi:"organisationId"`
	// The port on which the targets receive traffic
	Port pulumi.IntOutput `pulumi:"port"`
	// The protocol to use for routing traffic to the targets. Must be one of: tcp, udp.
	Protocol pulumi.StringOutput `pulumi:"protocol"`
	Slug     pulumi.StringOutput `pulumi:"slug"`
	// The number of consecutive health check failures required before considering a target unhealthy
	UnhealthyThreshold pulumi.IntPtrOutput `pulumi:"unhealthyThreshold"`
	// The VPC this target group belongs to
	VpcId pulumi.StringOutput `pulumi:"vpcId"`
}

// NewTargetGroup registers a new resource with the given unique name, arguments, and options.
func NewTargetGroup(ctx *pulumi.Context,
	name string, args *TargetGroupArgs, opts ...pulumi.ResourceOption) (*TargetGroup, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Port == nil {
		return nil, errors.New("invalid value for required argument 'Port'")
	}
	if args.Protocol == nil {
		return nil, errors.New("invalid value for required argument 'Protocol'")
	}
	if args.VpcId == nil {
		return nil, errors.New("invalid value for required argument 'VpcId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource TargetGroup
	err := ctx.RegisterResource("thalassa:index/targetGroup:TargetGroup", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetTargetGroup gets an existing TargetGroup resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetTargetGroup(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *TargetGroupState, opts ...pulumi.ResourceOption) (*TargetGroup, error) {
	var resource TargetGroup
	err := ctx.ReadResource("thalassa:index/targetGroup:TargetGroup", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering TargetGroup resources.
type targetGroupState struct {
	// Annotations for the Target Group
	Annotations map[string]string `pulumi:"annotations"`
	// The targets to attach to the target group. If provided, the targets will be attached to the target group when the resource is created. Overwrites the target group attachment resource.
	Attachments []TargetGroupAttachmentType `pulumi:"attachments"`
	// A human readable description about the target group
	Description *string `pulumi:"description"`
	// The approximate amount of time, in seconds, between health checks of an individual target
	HealthCheckInterval *int `pulumi:"healthCheckInterval"`
	// The path to use for health checks (only for HTTP/HTTPS)
	HealthCheckPath *string `pulumi:"healthCheckPath"`
	// The port to use for health checks
	HealthCheckPort *int `pulumi:"healthCheckPort"`
	// The protocol to use for health checks. Must be one of: tcp, http.
	HealthCheckProtocol *string `pulumi:"healthCheckProtocol"`
	// The amount of time, in seconds, during which no response means a failed health check
	HealthCheckTimeout *int `pulumi:"healthCheckTimeout"`
	// The number of consecutive health checks successes required before considering an unhealthy target healthy
	HealthyThreshold *int `pulumi:"healthyThreshold"`
	// Labels for the Target Group
	Labels map[string]string `pulumi:"labels"`
	// Name of the Target Group
	Name           *string `pulumi:"name"`
	OrganisationId *string `pulumi:"organisationId"`
	// The port on which the targets receive traffic
	Port *int `pulumi:"port"`
	// The protocol to use for routing traffic to the targets. Must be one of: tcp, udp.
	Protocol *string `pulumi:"protocol"`
	Slug     *string `pulumi:"slug"`
	// The number of consecutive health check failures required before considering a target unhealthy
	UnhealthyThreshold *int `pulumi:"unhealthyThreshold"`
	// The VPC this target group belongs to
	VpcId *string `pulumi:"vpcId"`
}

type TargetGroupState struct {
	// Annotations for the Target Group
	Annotations pulumi.StringMapInput
	// The targets to attach to the target group. If provided, the targets will be attached to the target group when the resource is created. Overwrites the target group attachment resource.
	Attachments TargetGroupAttachmentTypeArrayInput
	// A human readable description about the target group
	Description pulumi.StringPtrInput
	// The approximate amount of time, in seconds, between health checks of an individual target
	HealthCheckInterval pulumi.IntPtrInput
	// The path to use for health checks (only for HTTP/HTTPS)
	HealthCheckPath pulumi.StringPtrInput
	// The port to use for health checks
	HealthCheckPort pulumi.IntPtrInput
	// The protocol to use for health checks. Must be one of: tcp, http.
	HealthCheckProtocol pulumi.StringPtrInput
	// The amount of time, in seconds, during which no response means a failed health check
	HealthCheckTimeout pulumi.IntPtrInput
	// The number of consecutive health checks successes required before considering an unhealthy target healthy
	HealthyThreshold pulumi.IntPtrInput
	// Labels for the Target Group
	Labels pulumi.StringMapInput
	// Name of the Target Group
	Name           pulumi.StringPtrInput
	OrganisationId pulumi.StringPtrInput
	// The port on which the targets receive traffic
	Port pulumi.IntPtrInput
	// The protocol to use for routing traffic to the targets. Must be one of: tcp, udp.
	Protocol pulumi.StringPtrInput
	Slug     pulumi.StringPtrInput
	// The number of consecutive health check failures required before considering a target unhealthy
	UnhealthyThreshold pulumi.IntPtrInput
	// The VPC this target group belongs to
	VpcId pulumi.StringPtrInput
}

func (TargetGroupState) ElementType() reflect.Type {
	return reflect.TypeOf((*targetGroupState)(nil)).Elem()
}

type targetGroupArgs struct {
	// Annotations for the Target Group
	Annotations map[string]string `pulumi:"annotations"`
	// The targets to attach to the target group. If provided, the targets will be attached to the target group when the resource is created. Overwrites the target group attachment resource.
	Attachments []TargetGroupAttachmentType `pulumi:"attachments"`
	// A human readable description about the target group
	Description *string `pulumi:"description"`
	// The approximate amount of time, in seconds, between health checks of an individual target
	HealthCheckInterval *int `pulumi:"healthCheckInterval"`
	// The path to use for health checks (only for HTTP/HTTPS)
	HealthCheckPath *string `pulumi:"healthCheckPath"`
	// The port to use for health checks
	HealthCheckPort *int `pulumi:"healthCheckPort"`
	// The protocol to use for health checks. Must be one of: tcp, http.
	HealthCheckProtocol *string `pulumi:"healthCheckProtocol"`
	// The amount of time, in seconds, during which no response means a failed health check
	HealthCheckTimeout *int `pulumi:"healthCheckTimeout"`
	// The number of consecutive health checks successes required before considering an unhealthy target healthy
	HealthyThreshold *int `pulumi:"healthyThreshold"`
	// Labels for the Target Group
	Labels map[string]string `pulumi:"labels"`
	// Name of the Target Group
	Name           *string `pulumi:"name"`
	OrganisationId *string `pulumi:"organisationId"`
	// The port on which the targets receive traffic
	Port int `pulumi:"port"`
	// The protocol to use for routing traffic to the targets. Must be one of: tcp, udp.
	Protocol string `pulumi:"protocol"`
	// The number of consecutive health check failures required before considering a target unhealthy
	UnhealthyThreshold *int `pulumi:"unhealthyThreshold"`
	// The VPC this target group belongs to
	VpcId string `pulumi:"vpcId"`
}

// The set of arguments for constructing a TargetGroup resource.
type TargetGroupArgs struct {
	// Annotations for the Target Group
	Annotations pulumi.StringMapInput
	// The targets to attach to the target group. If provided, the targets will be attached to the target group when the resource is created. Overwrites the target group attachment resource.
	Attachments TargetGroupAttachmentTypeArrayInput
	// A human readable description about the target group
	Description pulumi.StringPtrInput
	// The approximate amount of time, in seconds, between health checks of an individual target
	HealthCheckInterval pulumi.IntPtrInput
	// The path to use for health checks (only for HTTP/HTTPS)
	HealthCheckPath pulumi.StringPtrInput
	// The port to use for health checks
	HealthCheckPort pulumi.IntPtrInput
	// The protocol to use for health checks. Must be one of: tcp, http.
	HealthCheckProtocol pulumi.StringPtrInput
	// The amount of time, in seconds, during which no response means a failed health check
	HealthCheckTimeout pulumi.IntPtrInput
	// The number of consecutive health checks successes required before considering an unhealthy target healthy
	HealthyThreshold pulumi.IntPtrInput
	// Labels for the Target Group
	Labels pulumi.StringMapInput
	// Name of the Target Group
	Name           pulumi.StringPtrInput
	OrganisationId pulumi.StringPtrInput
	// The port on which the targets receive traffic
	Port pulumi.IntInput
	// The protocol to use for routing traffic to the targets. Must be one of: tcp, udp.
	Protocol pulumi.StringInput
	// The number of consecutive health check failures required before considering a target unhealthy
	UnhealthyThreshold pulumi.IntPtrInput
	// The VPC this target group belongs to
	VpcId pulumi.StringInput
}

func (TargetGroupArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*targetGroupArgs)(nil)).Elem()
}

type TargetGroupInput interface {
	pulumi.Input

	ToTargetGroupOutput() TargetGroupOutput
	ToTargetGroupOutputWithContext(ctx context.Context) TargetGroupOutput
}

func (*TargetGroup) ElementType() reflect.Type {
	return reflect.TypeOf((**TargetGroup)(nil)).Elem()
}

func (i *TargetGroup) ToTargetGroupOutput() TargetGroupOutput {
	return i.ToTargetGroupOutputWithContext(context.Background())
}

func (i *TargetGroup) ToTargetGroupOutputWithContext(ctx context.Context) TargetGroupOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TargetGroupOutput)
}

// TargetGroupArrayInput is an input type that accepts TargetGroupArray and TargetGroupArrayOutput values.
// You can construct a concrete instance of `TargetGroupArrayInput` via:
//
//	TargetGroupArray{ TargetGroupArgs{...} }
type TargetGroupArrayInput interface {
	pulumi.Input

	ToTargetGroupArrayOutput() TargetGroupArrayOutput
	ToTargetGroupArrayOutputWithContext(context.Context) TargetGroupArrayOutput
}

type TargetGroupArray []TargetGroupInput

func (TargetGroupArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*TargetGroup)(nil)).Elem()
}

func (i TargetGroupArray) ToTargetGroupArrayOutput() TargetGroupArrayOutput {
	return i.ToTargetGroupArrayOutputWithContext(context.Background())
}

func (i TargetGroupArray) ToTargetGroupArrayOutputWithContext(ctx context.Context) TargetGroupArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TargetGroupArrayOutput)
}

// TargetGroupMapInput is an input type that accepts TargetGroupMap and TargetGroupMapOutput values.
// You can construct a concrete instance of `TargetGroupMapInput` via:
//
//	TargetGroupMap{ "key": TargetGroupArgs{...} }
type TargetGroupMapInput interface {
	pulumi.Input

	ToTargetGroupMapOutput() TargetGroupMapOutput
	ToTargetGroupMapOutputWithContext(context.Context) TargetGroupMapOutput
}

type TargetGroupMap map[string]TargetGroupInput

func (TargetGroupMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*TargetGroup)(nil)).Elem()
}

func (i TargetGroupMap) ToTargetGroupMapOutput() TargetGroupMapOutput {
	return i.ToTargetGroupMapOutputWithContext(context.Background())
}

func (i TargetGroupMap) ToTargetGroupMapOutputWithContext(ctx context.Context) TargetGroupMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TargetGroupMapOutput)
}

type TargetGroupOutput struct{ *pulumi.OutputState }

func (TargetGroupOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TargetGroup)(nil)).Elem()
}

func (o TargetGroupOutput) ToTargetGroupOutput() TargetGroupOutput {
	return o
}

func (o TargetGroupOutput) ToTargetGroupOutputWithContext(ctx context.Context) TargetGroupOutput {
	return o
}

// Annotations for the Target Group
func (o TargetGroupOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v *TargetGroup) pulumi.StringMapOutput { return v.Annotations }).(pulumi.StringMapOutput)
}

// The targets to attach to the target group. If provided, the targets will be attached to the target group when the resource is created. Overwrites the target group attachment resource.
func (o TargetGroupOutput) Attachments() TargetGroupAttachmentTypeArrayOutput {
	return o.ApplyT(func(v *TargetGroup) TargetGroupAttachmentTypeArrayOutput { return v.Attachments }).(TargetGroupAttachmentTypeArrayOutput)
}

// A human readable description about the target group
func (o TargetGroupOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TargetGroup) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// The approximate amount of time, in seconds, between health checks of an individual target
func (o TargetGroupOutput) HealthCheckInterval() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *TargetGroup) pulumi.IntPtrOutput { return v.HealthCheckInterval }).(pulumi.IntPtrOutput)
}

// The path to use for health checks (only for HTTP/HTTPS)
func (o TargetGroupOutput) HealthCheckPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TargetGroup) pulumi.StringPtrOutput { return v.HealthCheckPath }).(pulumi.StringPtrOutput)
}

// The port to use for health checks
func (o TargetGroupOutput) HealthCheckPort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *TargetGroup) pulumi.IntPtrOutput { return v.HealthCheckPort }).(pulumi.IntPtrOutput)
}

// The protocol to use for health checks. Must be one of: tcp, http.
func (o TargetGroupOutput) HealthCheckProtocol() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TargetGroup) pulumi.StringPtrOutput { return v.HealthCheckProtocol }).(pulumi.StringPtrOutput)
}

// The amount of time, in seconds, during which no response means a failed health check
func (o TargetGroupOutput) HealthCheckTimeout() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *TargetGroup) pulumi.IntPtrOutput { return v.HealthCheckTimeout }).(pulumi.IntPtrOutput)
}

// The number of consecutive health checks successes required before considering an unhealthy target healthy
func (o TargetGroupOutput) HealthyThreshold() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *TargetGroup) pulumi.IntPtrOutput { return v.HealthyThreshold }).(pulumi.IntPtrOutput)
}

// Labels for the Target Group
func (o TargetGroupOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *TargetGroup) pulumi.StringMapOutput { return v.Labels }).(pulumi.StringMapOutput)
}

// Name of the Target Group
func (o TargetGroupOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *TargetGroup) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

func (o TargetGroupOutput) OrganisationId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TargetGroup) pulumi.StringPtrOutput { return v.OrganisationId }).(pulumi.StringPtrOutput)
}

// The port on which the targets receive traffic
func (o TargetGroupOutput) Port() pulumi.IntOutput {
	return o.ApplyT(func(v *TargetGroup) pulumi.IntOutput { return v.Port }).(pulumi.IntOutput)
}

// The protocol to use for routing traffic to the targets. Must be one of: tcp, udp.
func (o TargetGroupOutput) Protocol() pulumi.StringOutput {
	return o.ApplyT(func(v *TargetGroup) pulumi.StringOutput { return v.Protocol }).(pulumi.StringOutput)
}

func (o TargetGroupOutput) Slug() pulumi.StringOutput {
	return o.ApplyT(func(v *TargetGroup) pulumi.StringOutput { return v.Slug }).(pulumi.StringOutput)
}

// The number of consecutive health check failures required before considering a target unhealthy
func (o TargetGroupOutput) UnhealthyThreshold() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *TargetGroup) pulumi.IntPtrOutput { return v.UnhealthyThreshold }).(pulumi.IntPtrOutput)
}

// The VPC this target group belongs to
func (o TargetGroupOutput) VpcId() pulumi.StringOutput {
	return o.ApplyT(func(v *TargetGroup) pulumi.StringOutput { return v.VpcId }).(pulumi.StringOutput)
}

type TargetGroupArrayOutput struct{ *pulumi.OutputState }

func (TargetGroupArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*TargetGroup)(nil)).Elem()
}

func (o TargetGroupArrayOutput) ToTargetGroupArrayOutput() TargetGroupArrayOutput {
	return o
}

func (o TargetGroupArrayOutput) ToTargetGroupArrayOutputWithContext(ctx context.Context) TargetGroupArrayOutput {
	return o
}

func (o TargetGroupArrayOutput) Index(i pulumi.IntInput) TargetGroupOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *TargetGroup {
		return vs[0].([]*TargetGroup)[vs[1].(int)]
	}).(TargetGroupOutput)
}

type TargetGroupMapOutput struct{ *pulumi.OutputState }

func (TargetGroupMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*TargetGroup)(nil)).Elem()
}

func (o TargetGroupMapOutput) ToTargetGroupMapOutput() TargetGroupMapOutput {
	return o
}

func (o TargetGroupMapOutput) ToTargetGroupMapOutputWithContext(ctx context.Context) TargetGroupMapOutput {
	return o
}

func (o TargetGroupMapOutput) MapIndex(k pulumi.StringInput) TargetGroupOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *TargetGroup {
		return vs[0].(map[string]*TargetGroup)[vs[1].(string)]
	}).(TargetGroupOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*TargetGroupInput)(nil)).Elem(), &TargetGroup{})
	pulumi.RegisterInputType(reflect.TypeOf((*TargetGroupArrayInput)(nil)).Elem(), TargetGroupArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TargetGroupMapInput)(nil)).Elem(), TargetGroupMap{})
	pulumi.RegisterOutputType(TargetGroupOutput{})
	pulumi.RegisterOutputType(TargetGroupArrayOutput{})
	pulumi.RegisterOutputType(TargetGroupMapOutput{})
}
