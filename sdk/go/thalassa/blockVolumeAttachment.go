// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package thalassa

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/sandervb2/pulumi-thalassa/sdk/go/thalassa/internal"
)

// Attach a block volume to a virtual machine. Volume must not be attached to another virtual machine.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/sandervb2/pulumi-thalassa/sdk/go/thalassa"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			// Create a VPC for the resources
//			example, err := thalassa.NewVpc(ctx, "example", &thalassa.VpcArgs{
//				Name:        pulumi.String("example-vpc"),
//				Description: pulumi.String("Example VPC for block volume attachment"),
//				Region:      pulumi.String("nl-01"),
//				Cidrs: pulumi.StringArray{
//					pulumi.String("10.0.0.0/16"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			// Create a subnet for the resources
//			exampleSubnet, err := thalassa.NewSubnet(ctx, "example", &thalassa.SubnetArgs{
//				Name:        pulumi.String("example-subnet"),
//				Description: pulumi.String("Example subnet for block volume attachment"),
//				VpcId:       example.ID(),
//				Cidr:        pulumi.String("10.0.1.0/24"),
//			})
//			if err != nil {
//				return err
//			}
//			// Create a block volume
//			exampleBlockVolume, err := thalassa.NewBlockVolume(ctx, "example", &thalassa.BlockVolumeArgs{
//				Name:        pulumi.String("example-block-volume"),
//				Description: pulumi.String("Example block volume for attachment"),
//				Region:      pulumi.String("nl-01"),
//				VolumeType:  pulumi.String("Block"),
//				SizeGb:      pulumi.Int(50),
//			})
//			if err != nil {
//				return err
//			}
//			// Create a virtual machine instance
//			exampleVirtualMachineInstance, err := thalassa.NewVirtualMachineInstance(ctx, "example", &thalassa.VirtualMachineInstanceArgs{
//				Name:             pulumi.String("example-instance"),
//				SubnetId:         exampleSubnet.ID(),
//				MachineType:      pulumi.String("pgp-small"),
//				MachineImage:     pulumi.String("ubuntu-22.04"),
//				AvailabilityZone: pulumi.String("nl-01a"),
//				RootVolumeSizeGb: pulumi.Int(20),
//				RootVolumeType:   pulumi.String("Block"),
//			})
//			if err != nil {
//				return err
//			}
//			// Create a block volume attachment with Thalassa default values
//			exampleBlockVolumeAttachment, err := thalassa.NewBlockVolumeAttachment(ctx, "example", &thalassa.BlockVolumeAttachmentArgs{
//				VolumeId: exampleBlockVolume.ID(),
//				VmiId:    exampleVirtualMachineInstance.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			ctx.Export("attachmentId", exampleBlockVolumeAttachment.ID())
//			ctx.Export("deviceSerial", exampleBlockVolumeAttachment.Serial)
//			return nil
//		})
//	}
//
// ```
type BlockVolumeAttachment struct {
	pulumi.CustomResourceState

	OrganisationId pulumi.StringPtrOutput `pulumi:"organisationId"`
	// The device name to use for the volume attachment (e.g., /dev/sdb)
	Serial pulumi.StringOutput `pulumi:"serial"`
	// The ID of the virtual machine to attach the volume to
	VmiId pulumi.StringOutput `pulumi:"vmiId"`
	// The ID of the volume to attach
	VolumeId pulumi.StringOutput `pulumi:"volumeId"`
	// Wait for the volume to be attached to the virtual machine. If false, the volume will be attached and the resource will be marked as created, but the volume may not be attached to the virtual machine yet.
	WaitForAttached pulumi.BoolPtrOutput `pulumi:"waitForAttached"`
	// The timeout in minutes to wait for the volume to be attached to the virtual machine. Only used if wait*for*attached is true. If not provided, the default timeout of 5 minutes will be used.
	WaitForAttachedTimeout pulumi.IntPtrOutput `pulumi:"waitForAttachedTimeout"`
	// Wait for the volume to be detached from the virtual machine. If false, the volume will be detached and the resource will be marked as deleted, but the volume may not be detached from the virtual machine yet.
	WaitForDetached pulumi.BoolPtrOutput `pulumi:"waitForDetached"`
	// The timeout in minutes to wait for the volume to be detached from the virtual machine. Only used if wait*for*detached is true. If not provided, the default timeout of 5 minutes will be used.
	WaitForDetachedTimeout pulumi.IntPtrOutput `pulumi:"waitForDetachedTimeout"`
}

// NewBlockVolumeAttachment registers a new resource with the given unique name, arguments, and options.
func NewBlockVolumeAttachment(ctx *pulumi.Context,
	name string, args *BlockVolumeAttachmentArgs, opts ...pulumi.ResourceOption) (*BlockVolumeAttachment, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.VmiId == nil {
		return nil, errors.New("invalid value for required argument 'VmiId'")
	}
	if args.VolumeId == nil {
		return nil, errors.New("invalid value for required argument 'VolumeId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource BlockVolumeAttachment
	err := ctx.RegisterResource("thalassa:index/blockVolumeAttachment:BlockVolumeAttachment", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetBlockVolumeAttachment gets an existing BlockVolumeAttachment resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetBlockVolumeAttachment(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *BlockVolumeAttachmentState, opts ...pulumi.ResourceOption) (*BlockVolumeAttachment, error) {
	var resource BlockVolumeAttachment
	err := ctx.ReadResource("thalassa:index/blockVolumeAttachment:BlockVolumeAttachment", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering BlockVolumeAttachment resources.
type blockVolumeAttachmentState struct {
	OrganisationId *string `pulumi:"organisationId"`
	// The device name to use for the volume attachment (e.g., /dev/sdb)
	Serial *string `pulumi:"serial"`
	// The ID of the virtual machine to attach the volume to
	VmiId *string `pulumi:"vmiId"`
	// The ID of the volume to attach
	VolumeId *string `pulumi:"volumeId"`
	// Wait for the volume to be attached to the virtual machine. If false, the volume will be attached and the resource will be marked as created, but the volume may not be attached to the virtual machine yet.
	WaitForAttached *bool `pulumi:"waitForAttached"`
	// The timeout in minutes to wait for the volume to be attached to the virtual machine. Only used if wait*for*attached is true. If not provided, the default timeout of 5 minutes will be used.
	WaitForAttachedTimeout *int `pulumi:"waitForAttachedTimeout"`
	// Wait for the volume to be detached from the virtual machine. If false, the volume will be detached and the resource will be marked as deleted, but the volume may not be detached from the virtual machine yet.
	WaitForDetached *bool `pulumi:"waitForDetached"`
	// The timeout in minutes to wait for the volume to be detached from the virtual machine. Only used if wait*for*detached is true. If not provided, the default timeout of 5 minutes will be used.
	WaitForDetachedTimeout *int `pulumi:"waitForDetachedTimeout"`
}

type BlockVolumeAttachmentState struct {
	OrganisationId pulumi.StringPtrInput
	// The device name to use for the volume attachment (e.g., /dev/sdb)
	Serial pulumi.StringPtrInput
	// The ID of the virtual machine to attach the volume to
	VmiId pulumi.StringPtrInput
	// The ID of the volume to attach
	VolumeId pulumi.StringPtrInput
	// Wait for the volume to be attached to the virtual machine. If false, the volume will be attached and the resource will be marked as created, but the volume may not be attached to the virtual machine yet.
	WaitForAttached pulumi.BoolPtrInput
	// The timeout in minutes to wait for the volume to be attached to the virtual machine. Only used if wait*for*attached is true. If not provided, the default timeout of 5 minutes will be used.
	WaitForAttachedTimeout pulumi.IntPtrInput
	// Wait for the volume to be detached from the virtual machine. If false, the volume will be detached and the resource will be marked as deleted, but the volume may not be detached from the virtual machine yet.
	WaitForDetached pulumi.BoolPtrInput
	// The timeout in minutes to wait for the volume to be detached from the virtual machine. Only used if wait*for*detached is true. If not provided, the default timeout of 5 minutes will be used.
	WaitForDetachedTimeout pulumi.IntPtrInput
}

func (BlockVolumeAttachmentState) ElementType() reflect.Type {
	return reflect.TypeOf((*blockVolumeAttachmentState)(nil)).Elem()
}

type blockVolumeAttachmentArgs struct {
	OrganisationId *string `pulumi:"organisationId"`
	// The ID of the virtual machine to attach the volume to
	VmiId string `pulumi:"vmiId"`
	// The ID of the volume to attach
	VolumeId string `pulumi:"volumeId"`
	// Wait for the volume to be attached to the virtual machine. If false, the volume will be attached and the resource will be marked as created, but the volume may not be attached to the virtual machine yet.
	WaitForAttached *bool `pulumi:"waitForAttached"`
	// The timeout in minutes to wait for the volume to be attached to the virtual machine. Only used if wait*for*attached is true. If not provided, the default timeout of 5 minutes will be used.
	WaitForAttachedTimeout *int `pulumi:"waitForAttachedTimeout"`
	// Wait for the volume to be detached from the virtual machine. If false, the volume will be detached and the resource will be marked as deleted, but the volume may not be detached from the virtual machine yet.
	WaitForDetached *bool `pulumi:"waitForDetached"`
	// The timeout in minutes to wait for the volume to be detached from the virtual machine. Only used if wait*for*detached is true. If not provided, the default timeout of 5 minutes will be used.
	WaitForDetachedTimeout *int `pulumi:"waitForDetachedTimeout"`
}

// The set of arguments for constructing a BlockVolumeAttachment resource.
type BlockVolumeAttachmentArgs struct {
	OrganisationId pulumi.StringPtrInput
	// The ID of the virtual machine to attach the volume to
	VmiId pulumi.StringInput
	// The ID of the volume to attach
	VolumeId pulumi.StringInput
	// Wait for the volume to be attached to the virtual machine. If false, the volume will be attached and the resource will be marked as created, but the volume may not be attached to the virtual machine yet.
	WaitForAttached pulumi.BoolPtrInput
	// The timeout in minutes to wait for the volume to be attached to the virtual machine. Only used if wait*for*attached is true. If not provided, the default timeout of 5 minutes will be used.
	WaitForAttachedTimeout pulumi.IntPtrInput
	// Wait for the volume to be detached from the virtual machine. If false, the volume will be detached and the resource will be marked as deleted, but the volume may not be detached from the virtual machine yet.
	WaitForDetached pulumi.BoolPtrInput
	// The timeout in minutes to wait for the volume to be detached from the virtual machine. Only used if wait*for*detached is true. If not provided, the default timeout of 5 minutes will be used.
	WaitForDetachedTimeout pulumi.IntPtrInput
}

func (BlockVolumeAttachmentArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*blockVolumeAttachmentArgs)(nil)).Elem()
}

type BlockVolumeAttachmentInput interface {
	pulumi.Input

	ToBlockVolumeAttachmentOutput() BlockVolumeAttachmentOutput
	ToBlockVolumeAttachmentOutputWithContext(ctx context.Context) BlockVolumeAttachmentOutput
}

func (*BlockVolumeAttachment) ElementType() reflect.Type {
	return reflect.TypeOf((**BlockVolumeAttachment)(nil)).Elem()
}

func (i *BlockVolumeAttachment) ToBlockVolumeAttachmentOutput() BlockVolumeAttachmentOutput {
	return i.ToBlockVolumeAttachmentOutputWithContext(context.Background())
}

func (i *BlockVolumeAttachment) ToBlockVolumeAttachmentOutputWithContext(ctx context.Context) BlockVolumeAttachmentOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BlockVolumeAttachmentOutput)
}

// BlockVolumeAttachmentArrayInput is an input type that accepts BlockVolumeAttachmentArray and BlockVolumeAttachmentArrayOutput values.
// You can construct a concrete instance of `BlockVolumeAttachmentArrayInput` via:
//
//	BlockVolumeAttachmentArray{ BlockVolumeAttachmentArgs{...} }
type BlockVolumeAttachmentArrayInput interface {
	pulumi.Input

	ToBlockVolumeAttachmentArrayOutput() BlockVolumeAttachmentArrayOutput
	ToBlockVolumeAttachmentArrayOutputWithContext(context.Context) BlockVolumeAttachmentArrayOutput
}

type BlockVolumeAttachmentArray []BlockVolumeAttachmentInput

func (BlockVolumeAttachmentArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*BlockVolumeAttachment)(nil)).Elem()
}

func (i BlockVolumeAttachmentArray) ToBlockVolumeAttachmentArrayOutput() BlockVolumeAttachmentArrayOutput {
	return i.ToBlockVolumeAttachmentArrayOutputWithContext(context.Background())
}

func (i BlockVolumeAttachmentArray) ToBlockVolumeAttachmentArrayOutputWithContext(ctx context.Context) BlockVolumeAttachmentArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BlockVolumeAttachmentArrayOutput)
}

// BlockVolumeAttachmentMapInput is an input type that accepts BlockVolumeAttachmentMap and BlockVolumeAttachmentMapOutput values.
// You can construct a concrete instance of `BlockVolumeAttachmentMapInput` via:
//
//	BlockVolumeAttachmentMap{ "key": BlockVolumeAttachmentArgs{...} }
type BlockVolumeAttachmentMapInput interface {
	pulumi.Input

	ToBlockVolumeAttachmentMapOutput() BlockVolumeAttachmentMapOutput
	ToBlockVolumeAttachmentMapOutputWithContext(context.Context) BlockVolumeAttachmentMapOutput
}

type BlockVolumeAttachmentMap map[string]BlockVolumeAttachmentInput

func (BlockVolumeAttachmentMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*BlockVolumeAttachment)(nil)).Elem()
}

func (i BlockVolumeAttachmentMap) ToBlockVolumeAttachmentMapOutput() BlockVolumeAttachmentMapOutput {
	return i.ToBlockVolumeAttachmentMapOutputWithContext(context.Background())
}

func (i BlockVolumeAttachmentMap) ToBlockVolumeAttachmentMapOutputWithContext(ctx context.Context) BlockVolumeAttachmentMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BlockVolumeAttachmentMapOutput)
}

type BlockVolumeAttachmentOutput struct{ *pulumi.OutputState }

func (BlockVolumeAttachmentOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BlockVolumeAttachment)(nil)).Elem()
}

func (o BlockVolumeAttachmentOutput) ToBlockVolumeAttachmentOutput() BlockVolumeAttachmentOutput {
	return o
}

func (o BlockVolumeAttachmentOutput) ToBlockVolumeAttachmentOutputWithContext(ctx context.Context) BlockVolumeAttachmentOutput {
	return o
}

func (o BlockVolumeAttachmentOutput) OrganisationId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BlockVolumeAttachment) pulumi.StringPtrOutput { return v.OrganisationId }).(pulumi.StringPtrOutput)
}

// The device name to use for the volume attachment (e.g., /dev/sdb)
func (o BlockVolumeAttachmentOutput) Serial() pulumi.StringOutput {
	return o.ApplyT(func(v *BlockVolumeAttachment) pulumi.StringOutput { return v.Serial }).(pulumi.StringOutput)
}

// The ID of the virtual machine to attach the volume to
func (o BlockVolumeAttachmentOutput) VmiId() pulumi.StringOutput {
	return o.ApplyT(func(v *BlockVolumeAttachment) pulumi.StringOutput { return v.VmiId }).(pulumi.StringOutput)
}

// The ID of the volume to attach
func (o BlockVolumeAttachmentOutput) VolumeId() pulumi.StringOutput {
	return o.ApplyT(func(v *BlockVolumeAttachment) pulumi.StringOutput { return v.VolumeId }).(pulumi.StringOutput)
}

// Wait for the volume to be attached to the virtual machine. If false, the volume will be attached and the resource will be marked as created, but the volume may not be attached to the virtual machine yet.
func (o BlockVolumeAttachmentOutput) WaitForAttached() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *BlockVolumeAttachment) pulumi.BoolPtrOutput { return v.WaitForAttached }).(pulumi.BoolPtrOutput)
}

// The timeout in minutes to wait for the volume to be attached to the virtual machine. Only used if wait*for*attached is true. If not provided, the default timeout of 5 minutes will be used.
func (o BlockVolumeAttachmentOutput) WaitForAttachedTimeout() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *BlockVolumeAttachment) pulumi.IntPtrOutput { return v.WaitForAttachedTimeout }).(pulumi.IntPtrOutput)
}

// Wait for the volume to be detached from the virtual machine. If false, the volume will be detached and the resource will be marked as deleted, but the volume may not be detached from the virtual machine yet.
func (o BlockVolumeAttachmentOutput) WaitForDetached() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *BlockVolumeAttachment) pulumi.BoolPtrOutput { return v.WaitForDetached }).(pulumi.BoolPtrOutput)
}

// The timeout in minutes to wait for the volume to be detached from the virtual machine. Only used if wait*for*detached is true. If not provided, the default timeout of 5 minutes will be used.
func (o BlockVolumeAttachmentOutput) WaitForDetachedTimeout() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *BlockVolumeAttachment) pulumi.IntPtrOutput { return v.WaitForDetachedTimeout }).(pulumi.IntPtrOutput)
}

type BlockVolumeAttachmentArrayOutput struct{ *pulumi.OutputState }

func (BlockVolumeAttachmentArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*BlockVolumeAttachment)(nil)).Elem()
}

func (o BlockVolumeAttachmentArrayOutput) ToBlockVolumeAttachmentArrayOutput() BlockVolumeAttachmentArrayOutput {
	return o
}

func (o BlockVolumeAttachmentArrayOutput) ToBlockVolumeAttachmentArrayOutputWithContext(ctx context.Context) BlockVolumeAttachmentArrayOutput {
	return o
}

func (o BlockVolumeAttachmentArrayOutput) Index(i pulumi.IntInput) BlockVolumeAttachmentOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *BlockVolumeAttachment {
		return vs[0].([]*BlockVolumeAttachment)[vs[1].(int)]
	}).(BlockVolumeAttachmentOutput)
}

type BlockVolumeAttachmentMapOutput struct{ *pulumi.OutputState }

func (BlockVolumeAttachmentMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*BlockVolumeAttachment)(nil)).Elem()
}

func (o BlockVolumeAttachmentMapOutput) ToBlockVolumeAttachmentMapOutput() BlockVolumeAttachmentMapOutput {
	return o
}

func (o BlockVolumeAttachmentMapOutput) ToBlockVolumeAttachmentMapOutputWithContext(ctx context.Context) BlockVolumeAttachmentMapOutput {
	return o
}

func (o BlockVolumeAttachmentMapOutput) MapIndex(k pulumi.StringInput) BlockVolumeAttachmentOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *BlockVolumeAttachment {
		return vs[0].(map[string]*BlockVolumeAttachment)[vs[1].(string)]
	}).(BlockVolumeAttachmentOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*BlockVolumeAttachmentInput)(nil)).Elem(), &BlockVolumeAttachment{})
	pulumi.RegisterInputType(reflect.TypeOf((*BlockVolumeAttachmentArrayInput)(nil)).Elem(), BlockVolumeAttachmentArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*BlockVolumeAttachmentMapInput)(nil)).Elem(), BlockVolumeAttachmentMap{})
	pulumi.RegisterOutputType(BlockVolumeAttachmentOutput{})
	pulumi.RegisterOutputType(BlockVolumeAttachmentArrayOutput{})
	pulumi.RegisterOutputType(BlockVolumeAttachmentMapOutput{})
}
